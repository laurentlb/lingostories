export class Story {
    constructor(updateInventory) {
        this.ink = null;
        this.name = null;
        this.lang = null;
        this.updateInventory = updateInventory;
    }

    async loadStory(name) {
        const storyData = await fetch(`/stories/${name}.ink.json`, {cache: "no-cache"})
            .then(response => response.json());
        this.ink = new window.inkjs.Story(storyData);

        this.metadata = await fetch(`/stories/${name}.tl.json`, {cache: "no-cache"})
            .then(response => response.json());

        if (this.metadata["items"]) {
            for (const item of this.metadata["items"]) {
                this.ink.ObserveVariable(item, this.updateInventory);
            }
        }
    }

    loadStoryFromText(text, speakers) {
        this.compiler = new inkjs.Compiler(text);
        this.metadata = { "sentences": {}, speakers };
        this.ink = this.compiler.Compile();
    }

    Continue() {
        const line = this.ink.Continue();
        return this.processLine(line, this.ink.currentTags);
    }

    get canContinue() {
        return this.ink.canContinue;
    }

    get currentChoices() {
        return this.ink.currentChoices;
    }

    ChooseChoiceIndex(index) {
        this.ink.ChooseChoiceIndex(index);
    }

    ResetState() {
        this.ink.ResetState();
    }

    extractSpeaker(line) {
        let text = line;
        // speaker: Hello
        let speaker = text.match(/^(\w*?):/);
        if (speaker) {
            speaker = speaker[1];
            text = text.substring(speaker.length + 1).trim();
            return [speaker, text];
        }

        // @speaker Hello
        speaker = text.match(/^@(\w*)/);
        if (speaker) {
            speaker = speaker[1];
            text = text.substring(speaker.length + 1).trim();
            return [speaker, text];
        }

        return [null, text];
    }

    translateChoice(choice, lang) {
        if (!this.metadata["sentences"][choice.text]) {
            // console.log("Missing translation for", choice.text);
            const [_, text] = this.extractSpeaker(choice.text);
            return text;
        }
        return this.metadata["sentences"][choice.text][lang];
    }

    speakerInfo(speaker) {
        if (!speaker) {
            return null;
        }
        if (!this.metadata["speakers"][speaker]) {
            return { "avatar": "unknown.svg", "color": "#26a" };
        }
        return this.metadata["speakers"][speaker];
    }

    // Process a line generated by Ink; parse the line, add metadata and translations.
    processLine(line, tags) {
        line = line.trim();

        if (line.startsWith("$image")) {
            const img = line.split(" ")[1];
            return {
                "img": img,
            };
        }

        if (line.startsWith("$audio")) {
            const audio = line.split(" ")[1];
            return {
                "audio": audio,
            };
        }

        if (line.startsWith("`")) {
            line = line.substring(1, line.length - 1);
        }

        const [speaker, text] = this.extractSpeaker(line);
        const result = {
            "speaker": this.speakerInfo(speaker),
            "isTitle": tags.includes("title"),
        };

        const hasTranslation = this.metadata["sentences"][line] !== undefined;
        if (hasTranslation) {
            for (const [key, value] of Object.entries(this.metadata["sentences"][line])) {
                result[key] = value;
            }
        } else {
            result[this.lang] = text;
            result["en"] = text;
            result["fr"] = text;
        }

        return result;
    }

}
